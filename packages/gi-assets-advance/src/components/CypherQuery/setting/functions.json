{
  "columns": ["name", "signature", "description", "roles"],
  "data": [
    {
      "row": [
        "apoc.coll.avg",
        "apoc.coll.avg(numbers :: LIST? OF NUMBER?) :: (FLOAT?)",
        "apoc.coll.avg([0.5,1,2.3])",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.coll.contains",
        "apoc.coll.contains(coll :: LIST? OF ANY?, value :: ANY?) :: (BOOLEAN?)",
        "apoc.coll.contains(coll, value) optimized contains operation (using a HashSet) (returns single row or not)",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.coll.containsAll",
        "apoc.coll.containsAll(coll :: LIST? OF ANY?, values :: LIST? OF ANY?) :: (BOOLEAN?)",
        "apoc.coll.containsAll(coll, values) optimized contains-all operation (using a HashSet) (returns single row or not)",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.coll.containsAllSorted",
        "apoc.coll.containsAllSorted(coll :: LIST? OF ANY?, values :: LIST? OF ANY?) :: (BOOLEAN?)",
        "apoc.coll.containsAllSorted(coll, value) optimized contains-all on a sorted list operation (Collections.binarySearch) (returns single row or not)",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.coll.containsSorted",
        "apoc.coll.containsSorted(coll :: LIST? OF ANY?, value :: ANY?) :: (BOOLEAN?)",
        "apoc.coll.containsSorted(coll, value) optimized contains on a sorted list operation (Collections.binarySearch) (returns single row or not)",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.coll.disjunction",
        "apoc.coll.disjunction(first :: LIST? OF ANY?, second :: LIST? OF ANY?) :: (LIST? OF ANY?)",
        "apoc.coll.disjunction(first, second) - returns the disjunct set of the two lists",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.coll.indexOf",
        "apoc.coll.indexOf(coll :: LIST? OF ANY?, value :: ANY?) :: (INTEGER?)",
        "apoc.coll.indexOf(coll, value) | position of value in the list",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.coll.intersection",
        "apoc.coll.intersection(first :: LIST? OF ANY?, second :: LIST? OF ANY?) :: (LIST? OF ANY?)",
        "apoc.coll.intersection(first, second) - returns the unique intersection of the two lists",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.coll.max",
        "apoc.coll.max(values :: LIST? OF ANY?) :: (ANY?)",
        "apoc.coll.max([0.5,1,2.3])",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.coll.min",
        "apoc.coll.min(values :: LIST? OF ANY?) :: (ANY?)",
        "apoc.coll.min([0.5,1,2.3])",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.coll.pairs",
        "apoc.coll.pairs(list :: LIST? OF ANY?) :: (LIST? OF ANY?)",
        "apoc.coll.pairs([1,2,3]) returns [1,2],[2,3],[3,null] ",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.coll.pairsMin",
        "apoc.coll.pairsMin(list :: LIST? OF ANY?) :: (LIST? OF ANY?)",
        "apoc.coll.pairsMin([1,2,3]) returns [1,2],[2,3]",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.coll.removeAll",
        "apoc.coll.removeAll(first :: LIST? OF ANY?, second :: LIST? OF ANY?) :: (LIST? OF ANY?)",
        "apoc.coll.removeAll(first, second) - returns first list with all elements of second list removed",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.coll.sort",
        "apoc.coll.sort(coll :: LIST? OF ANY?) :: (LIST? OF ANY?)",
        "apoc.coll.sort(coll) sort on Collections",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.coll.sortMaps",
        "apoc.coll.sortMaps(coll :: LIST? OF MAP?, prop :: STRING?) :: (LIST? OF ANY?)",
        "apoc.coll.sortMaps([maps], 'name') - sort maps by property",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.coll.sortNodes",
        "apoc.coll.sortNodes(coll :: LIST? OF NODE?, prop :: STRING?) :: (LIST? OF ANY?)",
        "apoc.coll.sortNodes([nodes], 'name') sort nodes by property",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.coll.subtract",
        "apoc.coll.subtract(first :: LIST? OF ANY?, second :: LIST? OF ANY?) :: (LIST? OF ANY?)",
        "apoc.coll.subtract(first, second) - returns unique set of first list with all elements of second list removed",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.coll.sum",
        "apoc.coll.sum(numbers :: LIST? OF NUMBER?) :: (FLOAT?)",
        "apoc.coll.sum([0.5,1,2.3])",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.coll.sumLongs",
        "apoc.coll.sumLongs(numbers :: LIST? OF NUMBER?) :: (INTEGER?)",
        "apoc.coll.sumLongs([1,3,3])",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.coll.toSet",
        "apoc.coll.toSet(values :: LIST? OF ANY?) :: (LIST? OF ANY?)",
        "apoc.coll.toSet([list]) returns a unique list backed by a set",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.coll.union",
        "apoc.coll.union(first :: LIST? OF ANY?, second :: LIST? OF ANY?) :: (LIST? OF ANY?)",
        "apoc.coll.union(first, second) - creates the distinct union of the 2 lists",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.coll.unionAll",
        "apoc.coll.unionAll(first :: LIST? OF ANY?, second :: LIST? OF ANY?) :: (LIST? OF ANY?)",
        "apoc.coll.unionAll(first, second) - creates the full union with duplicates of the two lists",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.coll.zip",
        "apoc.coll.zip(list1 :: LIST? OF ANY?, list2 :: LIST? OF ANY?) :: (LIST? OF ANY?)",
        "apoc.coll.zip([list1],[list2])",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.convert.fromJsonList",
        "apoc.convert.fromJsonList(list :: STRING?) :: (LIST? OF ANY?)",
        "apoc.convert.fromJsonList('[1,2,3]')",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.convert.fromJsonMap",
        "apoc.convert.fromJsonMap(map :: STRING?) :: (MAP?)",
        "apoc.convert.fromJsonMap('{\"a\":42,\"b\":\"foo\",\"c\":[1,2,3]}')",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.convert.getJsonProperty",
        "apoc.convert.getJsonProperty(node :: NODE?, key :: STRING?) :: (ANY?)",
        "apoc.json.getJsonProperty(node,key) - converts serialized JSON in property back to original object",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.convert.getJsonPropertyMap",
        "apoc.convert.getJsonPropertyMap(node :: NODE?, key :: STRING?) :: (MAP?)",
        "apoc.json.getJsonPropertyMap(node,key) - converts serialized JSON in property back to map",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.convert.toBoolean",
        "apoc.convert.toBoolean(bool :: ANY?) :: (BOOLEAN?)",
        "apoc.convert.toBoolean(value) | tries it's best to convert the value to a boolean",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.convert.toJson",
        "apoc.convert.toJson(value :: ANY?) :: (STRING?)",
        "apoc.convert.toJson([1,2,3]) or toJson({a:42,b:\"foo\",c:[1,2,3]})",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.convert.toList",
        "apoc.convert.toList(list :: ANY?) :: (LIST? OF ANY?)",
        "apoc.convert.toList(value) | tries it's best to convert the value to a list",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.convert.toMap",
        "apoc.convert.toMap(map :: ANY?) :: (MAP?)",
        "apoc.convert.toMap(value) | tries it's best to convert the value to a map",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.convert.toNode",
        "apoc.convert.toNode(node :: ANY?) :: (NODE?)",
        "apoc.convert.toNode(value) | tries it's best to convert the value to a node",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.convert.toRelationship",
        "apoc.convert.toRelationship(relationship :: ANY?) :: (RELATIONSHIP?)",
        "apoc.convert.toRelationship(value) | tries it's best to convert the value to a relationship",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.convert.toSet",
        "apoc.convert.toSet(list :: ANY?) :: (LIST? OF ANY?)",
        "apoc.convert.toSet(value) | tries it's best to convert the value to a set",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.convert.toString",
        "apoc.convert.toString(string :: ANY?) :: (STRING?)",
        "apoc.convert.toString(value) | tries it's best to convert the value to a string",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.create.uuid",
        "apoc.create.uuid() :: (STRING?)",
        "apoc.create.uuid() - creates an UUID",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.data.domain",
        "apoc.data.domain(url_or_email_address :: STRING?) :: (STRING?)",
        "apoc.data.domain('url_or_email_address') YIELD domain - extract the domain name from a url or an email address. If nothing was found, yield null.",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.date.fields",
        "apoc.date.fields(date :: STRING?, pattern = yyyy-MM-dd HH:mm:ss :: STRING?) :: (MAP?)",
        "apoc.date.fields('2012-12-23',('yyyy-MM-dd')) - return columns and a map representation of date parsed with the given format with entries for years,months,weekdays,days,hours,minutes,seconds,zoneid",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.date.format",
        "apoc.date.format(time :: INTEGER?, unit = ms :: STRING?, format = yyyy-MM-dd HH:mm:ss :: STRING?, timezone =  :: STRING?) :: (STRING?)",
        "apoc.date.format(12345,('ms|s|m|h|d'),('yyyy-MM-dd HH:mm:ss zzz'),('TZ')) get string representation of time value optionally using the specified unit (default ms) using specified format (default ISO) and specified time zone (default current TZ)",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.date.parse",
        "apoc.date.parse(time :: STRING?, unit = ms :: STRING?, format = yyyy-MM-dd HH:mm:ss :: STRING?, timezone =  :: STRING?) :: (INTEGER?)",
        "apoc.date.parse('2012-12-23','ms|s|m|h|d','yyyy-MM-dd') parse date string using the specified format into the specified time unit",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.date.systemTimezone",
        "apoc.date.systemTimezone() :: (STRING?)",
        "apoc.date.systemTimezone() returns the system timezone display name",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.date.toYears",
        "apoc.date.toYears(value :: ANY?, format = yyyy-MM-dd HH:mm:ss :: STRING?) :: (FLOAT?)",
        "toYears(timestap) or toYears(date[,format]) converts timestamp into floating point years",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.map.clean",
        "apoc.map.clean(map :: MAP?, keys :: LIST? OF STRING?, values :: LIST? OF ANY?) :: (MAP?)",
        "apoc.map.clean(map,[skip,keys],[skip,values]) yield map removes the keys and values contained in those lists, good for data cleaning from CSV/JSON",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.map.flatten",
        "apoc.map.flatten(map :: MAP?) :: (MAP?)",
        "apoc.map.flatten(map) yield map - flattens nested items in map using dot notation",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.map.fromLists",
        "apoc.map.fromLists(keys :: LIST? OF STRING?, values :: LIST? OF ANY?) :: (MAP?)",
        "apoc.map.fromLists([keys],[values])",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.map.fromNodes",
        "apoc.map.fromNodes(label :: STRING?, property :: STRING?) :: (MAP?)",
        "apoc.map.fromNodes(label, property)",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.map.fromPairs",
        "apoc.map.fromPairs(pairs :: LIST? OF LIST? OF ANY?) :: (MAP?)",
        "apoc.map.fromPairs([[key,value],[key2,value2],...])",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.map.fromValues",
        "apoc.map.fromValues(values :: LIST? OF ANY?) :: (MAP?)",
        "apoc.map.fromValues([key1,value1,key2,value2,...])",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.map.groupBy",
        "apoc.map.groupBy(values :: LIST? OF ANY?, key :: STRING?) :: (MAP?)",
        "apoc.map.groupBy([maps/nodes/relationships],'key') yield value - creates a map of the list keyed by the given property, with single values",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.map.groupByMulti",
        "apoc.map.groupByMulti(values :: LIST? OF ANY?, key :: STRING?) :: (MAP?)",
        "apoc.map.groupByMulti([maps/nodes/relationships],'key') yield value - creates a map of the list keyed by the given property, with list values",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.map.merge",
        "apoc.map.merge(first :: MAP?, second :: MAP?) :: (MAP?)",
        "apoc.map.merge(first,second) - merges two maps",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.map.mergeList",
        "apoc.map.mergeList(maps :: LIST? OF MAP?) :: (MAP?)",
        "apoc.map.mergeList([{maps}]) yield value - merges all maps in the list into one",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.map.removeKey",
        "apoc.map.removeKey(map :: MAP?, key :: STRING?) :: (MAP?)",
        "apoc.map.removeKey(map,key)",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.map.removeKeys",
        "apoc.map.removeKeys(map :: MAP?, keys :: LIST? OF STRING?) :: (MAP?)",
        "apoc.map.removeKeys(map,keys)",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.map.setEntry",
        "apoc.map.setEntry(map :: MAP?, key :: STRING?, value :: ANY?) :: (MAP?)",
        "apoc.map.setEntry(map,key,value)",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.map.setKey",
        "apoc.map.setKey(map :: MAP?, key :: STRING?, value :: ANY?) :: (MAP?)",
        "apoc.map.setKey(map,key,value)",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.map.setLists",
        "apoc.map.setLists(map :: MAP?, keys :: LIST? OF STRING?, values :: LIST? OF ANY?) :: (MAP?)",
        "apoc.map.setLists(map,[keys],[values])",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.map.setPairs",
        "apoc.map.setPairs(map :: MAP?, pairs :: LIST? OF LIST? OF ANY?) :: (MAP?)",
        "apoc.map.setPairs(map,[[key1,value1],[key2,value2])",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.map.setValues",
        "apoc.map.setValues(map :: MAP?, pairs :: LIST? OF ANY?) :: (MAP?)",
        "apoc.map.setValues(map,[key1,value1,key2,value2])",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.math.round",
        "apoc.math.round(value :: FLOAT?, precision = 0 :: INTEGER?, mode = HALF_UP :: STRING?) :: (FLOAT?)",
        "apoc.math.round(value,[prec],mode=[CEILING,FLOOR,UP,DOWN,HALF_EVEN,HALF_DOWN,HALF_UP,DOWN,UNNECESSARY])",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.meta.isType",
        "apoc.meta.isType(value :: ANY?, type :: STRING?) :: (BOOLEAN?)",
        "apoc.meta.isType(value,type) - returns a row if type name matches none if not (INTEGER,FLOAT,STRING,BOOLEAN,RELATIONSHIP,NODE,PATH,NULL,UNKNOWN,MAP,LIST)",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.meta.type",
        "apoc.meta.type(value :: ANY?) :: (STRING?)",
        "apoc.meta.type(value) - type name of a value (INTEGER,FLOAT,STRING,BOOLEAN,RELATIONSHIP,NODE,PATH,NULL,UNKNOWN,MAP,LIST)",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.meta.typeName",
        "apoc.meta.typeName(value :: ANY?) :: (STRING?)",
        "apoc.meta.typeName(value) - type name of a value (INTEGER,FLOAT,STRING,BOOLEAN,RELATIONSHIP,NODE,PATH,NULL,UNKNOWN,MAP,LIST)",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.meta.types",
        "apoc.meta.types(properties :: ANY?) :: (MAP?)",
        "apoc.meta.types(node-relationship-map)  - returns a map of keys to types",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.node.relationship.exists",
        "apoc.node.relationship.exists(node :: NODE?, types :: STRING?) :: (BOOLEAN?)",
        "apoc.node.relationship.exists(node, rel-direction-pattern) - yields true effectively when the node has the relationships of the pattern",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.nodes.isDense",
        "apoc.nodes.isDense(node :: NODE?) :: (BOOLEAN?)",
        "apoc.nodes.isDense(node) - returns true if it is a dense node",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.number.format",
        "apoc.number.format(number :: ANY?, pattern =  :: STRING?, lang =  :: STRING?) :: (STRING?)",
        "apoc.number.format(number)  | format a long or double using the default system pattern and language to produce a string",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.number.parseFloat",
        "apoc.number.parseFloat(text :: STRING?, pattern =  :: STRING?, lang =  :: STRING?) :: (FLOAT?)",
        "apoc.number.parseFloat(text)  | parse a text using the default system pattern and language to produce a double",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.number.parseInt",
        "apoc.number.parseInt(text :: STRING?, pattern =  :: STRING?, lang =  :: STRING?) :: (INTEGER?)",
        "apoc.number.parseInt(text)  | parse a text using the default system pattern and language to produce a long",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.scoring.existence",
        "apoc.scoring.existence(score :: INTEGER?, exists :: BOOLEAN?) :: (FLOAT?)",
        "apoc.scoring.existence(5, true) returns the provided score if true, 0 if false",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.scoring.pareto",
        "apoc.scoring.pareto(minimumThreshold :: INTEGER?, eightyPercentValue :: INTEGER?, maximumValue :: INTEGER?, score :: INTEGER?) :: (FLOAT?)",
        "apoc.scoring.pareto(10, 20, 100, 11) applies a Pareto scoring function over the inputs",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.text.clean",
        "apoc.text.clean(text :: STRING?) :: (STRING?)",
        "apoc.text.clean(text) - strip the given string of everything except alpha numeric characters and convert it to lower case.",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.text.compareCleaned",
        "apoc.text.compareCleaned(text1 :: STRING?, text2 :: STRING?) :: (BOOLEAN?)",
        "apoc.text.compareCleaned(text1, text2) - compare the given strings stripped of everything except alpha numeric characters converted to lower case.",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.text.join",
        "apoc.text.join(texts :: LIST? OF STRING?, delimiter :: STRING?) :: (STRING?)",
        "apoc.text.join(['text1','text2',...], delimiter) - join the given strings with the given delimiter.",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.text.regreplace",
        "apoc.text.regreplace(text :: STRING?, regex :: STRING?, replacement :: STRING?) :: (STRING?)",
        "apoc.text.regreplace(text, regex, replacement) - replace each substring of the given string that matches the given regular expression with the given replacement.",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.text.replace",
        "apoc.text.replace(text :: STRING?, regex :: STRING?, replacement :: STRING?) :: (STRING?)",
        "apoc.text.replace(text, regex, replacement) - replace each substring of the given string that matches the given regular expression with the given replacement.",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.text.urldecode",
        "apoc.text.urldecode(text :: STRING?) :: (STRING?)",
        "apoc.text.urldecode(text) - return the urldecoded text",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.text.urlencode",
        "apoc.text.urlencode(text :: STRING?) :: (STRING?)",
        "apoc.text.urlencode(text) - return the urlencoded text",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.trigger.nodesByLabel",
        "apoc.trigger.nodesByLabel(labelEntries :: ANY?, label :: STRING?) :: (LIST? OF ANY?)",
        "",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.trigger.propertiesByKey",
        "apoc.trigger.propertiesByKey(propertyEntries :: ANY?, key :: STRING?) :: (LIST? OF ANY?)",
        "",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.util.md5",
        "apoc.util.md5(values :: LIST? OF ANY?) :: (STRING?)",
        "apoc.util.md5([values]) | computes the md5 of the concatenation of all string values of the list",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.util.sha1",
        "apoc.util.sha1(values :: LIST? OF ANY?) :: (STRING?)",
        "apoc.util.sha1([values]) | computes the sha1 of the concatenation of all string values of the list",
        ["admin", "reader", "publisher", "architect"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    }
  ],
  "stats": {
    "nodes_created": 0,
    "nodes_deleted": 0,
    "relationships_created": 0,
    "relationships_deleted": 0,
    "properties_set": 0,
    "labels_added": 0,
    "labels_removed": 0,
    "indexes_added": 0,
    "indexes_removed": 0,
    "constraints_added": 0,
    "constraints_removed": 0,
    "contains_updates": false
  }
}
