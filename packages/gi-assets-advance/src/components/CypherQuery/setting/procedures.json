{
  "columns": ["name", "signature", "description", "roles"],
  "data": [
    {
      "row": [
        "apoc.algo.aStar",
        "apoc.algo.aStar(startNode :: NODE?, endNode :: NODE?, relationshipTypesAndDirections :: STRING?, weightPropertyName :: STRING?, latPropertyName :: STRING?, lonPropertyName :: STRING?) :: (path :: PATH?, weight :: FLOAT?)",
        "apoc.algo.aStar(startNode, endNode, 'KNOWS|<WORKS_WITH|IS_MANAGER_OF>', 'distance','lat','lon') YIELD path, weight - run A* with relationship property name as cost function",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.algo.aStarConfig",
        "apoc.algo.aStarConfig(startNode :: NODE?, endNode :: NODE?, relationshipTypesAndDirections :: STRING?, config :: MAP?) :: (path :: PATH?, weight :: FLOAT?)",
        "apoc.algo.aStar(startNode, endNode, 'KNOWS|<WORKS_WITH|IS_MANAGER_OF>', {weight:'dist',default:10,x:'lon',y:'lat'}) YIELD path, weight - run A* with relationship property name as cost function",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.algo.allSimplePaths",
        "apoc.algo.allSimplePaths(startNode :: NODE?, endNode :: NODE?, relationshipTypesAndDirections :: STRING?, maxNodes :: INTEGER?) :: (path :: PATH?)",
        "apoc.algo.allSimplePaths(startNode, endNode, 'KNOWS|<WORKS_WITH|IS_MANAGER_OF>', 5) YIELD path, weight - run allSimplePaths with relationships given and maxNodes",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.algo.betweenness",
        "apoc.algo.betweenness(types :: LIST? OF STRING?, nodes :: LIST? OF NODE?, direction :: STRING?) :: (node :: NODE?, score :: FLOAT?)",
        "CALL apoc.algo.betweenness(['TYPE',...],nodes,BOTH) YIELD node, score - calculate betweenness centrality for given nodes",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.algo.betweennessCypher",
        "apoc.algo.betweennessCypher(config :: MAP?) :: (nodes :: INTEGER?, relationships :: INTEGER?, readNodeMillis :: INTEGER?, readRelationshipMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, write :: BOOLEAN?, property :: STRING?)",
        "CALL apoc.algo.betweennessCypher(node_cypher,rel_cypher,write) - calculates betweeness  centrality based on cypher input",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.algo.cliques",
        "apoc.algo.cliques(minSize :: NUMBER?) :: (clique :: LIST? OF NODE?)",
        "apoc.algo.cliques(minSize) YIELD cliques - search the graph and return all maximal cliques at least at large as the minimum size argument.",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.algo.cliquesWithNode",
        "apoc.algo.cliquesWithNode(startNode :: NODE?, minSize :: NUMBER?) :: (clique :: LIST? OF NODE?)",
        "apoc.algo.cliquesWithNode(startNode, minSize) YIELD cliques - search the graph and return all maximal cliques that are at least as large than the minimum size argument and contain this node ",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.algo.closeness",
        "apoc.algo.closeness(types :: LIST? OF STRING?, nodes :: LIST? OF NODE?, direction :: STRING?) :: (node :: NODE?, score :: FLOAT?)",
        "CALL apoc.algo.closeness(['TYPE',...],nodes, INCOMING) YIELD node, score - calculate closeness centrality for given nodes",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.algo.community",
        "apoc.algo.community(times :: INTEGER?, labels :: LIST? OF STRING?, partitionKey :: STRING?, type :: STRING?, direction :: STRING?, weightKey :: STRING?, batchSize :: INTEGER?) :: VOID",
        "CALL apoc.algo.community(times,labels,partitionKey,type,direction,weightKey,batchSize) - simple label propagation kernel",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.algo.cover",
        "apoc.algo.cover(nodes :: ANY?) :: (rel :: RELATIONSHIP?)",
        "apoc.algo.cover(nodes) yield rel - returns all relationships between this set of nodes",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.algo.dijkstra",
        "apoc.algo.dijkstra(startNode :: NODE?, endNode :: NODE?, relationshipTypesAndDirections :: STRING?, weightPropertyName :: STRING?) :: (path :: PATH?, weight :: FLOAT?)",
        "apoc.algo.dijkstra(startNode, endNode, 'KNOWS|<WORKS_WITH|IS_MANAGER_OF>', 'distance') YIELD path, weight - run dijkstra with relationship property name as cost function",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.algo.dijkstraWithDefaultWeight",
        "apoc.algo.dijkstraWithDefaultWeight(startNode :: NODE?, endNode :: NODE?, relationshipTypesAndDirections :: STRING?, weightPropertyName :: STRING?, defaultWeight :: FLOAT?) :: (path :: PATH?, weight :: FLOAT?)",
        "apoc.algo.dijkstraWithDefaultWeight(startNode, endNode, 'KNOWS|<WORKS_WITH|IS_MANAGER_OF>', 'distance', 10) YIELD path, weight - run dijkstra with relationship property name as cost function and a default weight if the property does not exist",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.algo.pageRank",
        "apoc.algo.pageRank(nodes :: LIST? OF NODE?) :: (node :: NODE?, score :: FLOAT?)",
        "CALL apoc.algo.pageRank(nodes) YIELD node, score - calculates page rank for given nodes",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.algo.pageRankStats",
        "apoc.algo.pageRankStats(config :: MAP?) :: (nodes :: INTEGER?, relationships :: INTEGER?, iterations :: INTEGER?, readNodeMillis :: INTEGER?, readRelationshipMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, write :: BOOLEAN?, property :: STRING?)",
        "CALL apoc.algo.pageRankStats({iterations:_,types:_,write:true,...}) YIELD nodeCount - calculates page rank on graph  for given nodes and potentially writes back",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.algo.pageRankWithConfig",
        "apoc.algo.pageRankWithConfig(nodes :: LIST? OF NODE?, config :: MAP?) :: (node :: NODE?, score :: FLOAT?)",
        "CALL apoc.algo.pageRankWithConfig(nodes,{iterations:_,types:_}) YIELD node, score, info - calculates page rank for given nodes",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.algo.pageRankWithCypher",
        "apoc.algo.pageRankWithCypher(config :: MAP?) :: (nodes :: INTEGER?, relationships :: INTEGER?, iterations :: INTEGER?, readNodeMillis :: INTEGER?, readRelationshipMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, write :: BOOLEAN?, property :: STRING?)",
        "CALL apoc.algo.pageRankWithCypher({iterations,node_cypher,rel_cypher,write,property,numCpu}) - calculates page rank based on cypher input",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.algo.wcc",
        "apoc.algo.wcc() :: (nodeIds :: LIST? OF INTEGER?, stats :: MAP?)",
        "CALL apoc.algo.wcc() YIELD number of weakly connected components",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.bitwise.op",
        "apoc.bitwise.op(a :: INTEGER?, operator :: STRING?, b :: INTEGER?) :: (value :: INTEGER?)",
        "apoc.bitwise.op(60,'|',13) bitwise operations a & b, a | b, a ^ b, ~a, a >> b, a >>> b, a << b. returns the result of the bitwise operation",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.cluster.graph",
        "apoc.cluster.graph() :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)",
        "",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.coll.partition",
        "apoc.coll.partition(values :: LIST? OF ANY?, batchSize :: INTEGER?) :: (value :: LIST? OF ANY?)",
        "apoc.coll.partition(list,batchSize)",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.coll.split",
        "apoc.coll.split(values :: LIST? OF ANY?, value :: ANY?) :: (value :: LIST? OF ANY?)",
        "apoc.coll.split(list,value) | splits collection on given values rows of lists, value itself will not be part of resulting lists",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.coll.zipToRows",
        "apoc.coll.zipToRows(list1 :: LIST? OF ANY?, list2 :: LIST? OF ANY?) :: (value :: LIST? OF ANY?)",
        "apoc.coll.zipToRows(list1,list2) - creates pairs like zip but emits one row per pair",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.config.list",
        "apoc.config.list() :: (key :: STRING?, value :: ANY?)",
        "",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.config.map",
        "apoc.config.map() :: (value :: MAP?)",
        "",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.convert.setJsonProperty",
        "apoc.convert.setJsonProperty(node :: NODE?, key :: STRING?, value :: ANY?) :: VOID",
        "apoc.json.setJsonProperty(node,key,complexValue) - sets value serialized to JSON as property with the given name on the node",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.convert.toTree",
        "apoc.convert.toTree(paths :: LIST? OF PATH?) :: (value :: MAP?)",
        "apoc.convert.toTree([paths]) creates a stream of nested documents representing the at least one root of these paths",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.couchbase.append",
        "apoc.couchbase.append(nodes :: LIST? OF STRING?, bucket :: STRING?, documentId :: STRING?, json :: STRING?) :: (id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?, content :: MAP?)",
        "apoc.couchbase.append(nodes, bucket, documentId, jsonDocument) yield id, expiry, cas, mutationToken, content - append a couchbase json document to an existing one.",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.couchbase.exists",
        "apoc.couchbase.exists(nodes :: LIST? OF STRING?, bucket :: STRING?, documentId :: STRING?) :: (value :: BOOLEAN?)",
        "apoc.couchbase.exists(nodes, bucket, documentId) yield value - check whether a couchbase json document with the given ID does exist.",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.couchbase.get",
        "apoc.couchbase.get(nodes :: LIST? OF STRING?, bucket :: STRING?, documentId :: STRING?) :: (id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?, content :: MAP?)",
        "apoc.couchbase.get(nodes, bucket, documentId) yield id, expiry, cas, mutationToken, content - retrieves a couchbase json document by its unique ID.",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.couchbase.insert",
        "apoc.couchbase.insert(nodes :: LIST? OF STRING?, bucket :: STRING?, documentId :: STRING?, json :: STRING?) :: (id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?, content :: MAP?)",
        "apoc.couchbase.insert(nodes, bucket, documentId, jsonDocument) yield id, expiry, cas, mutationToken, content - insert a couchbase json document with its unique ID.",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.couchbase.namedParamsQuery",
        "apoc.couchbase.namedParamsQuery(nodes :: LIST? OF STRING?, bucket :: STRING?, statement :: STRING?, paramNames :: LIST? OF STRING?, paramValues :: LIST? OF ANY?) :: (queryResult :: LIST? OF MAP?)",
        "apoc.couchbase.namedParamsQuery(nodes, bucket, statement, paramNames, paramValues) yield queryResult - executes a N1QL statement with named parameters.",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.couchbase.posParamsQuery",
        "apoc.couchbase.posParamsQuery(nodes :: LIST? OF STRING?, bucket :: STRING?, statement :: STRING?, params :: LIST? OF ANY?) :: (queryResult :: LIST? OF MAP?)",
        "apoc.couchbase.posParamsQuery(nodes, bucket, statement, params) yield queryResult - executes a N1QL statement with positional parameters.",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.couchbase.prepend",
        "apoc.couchbase.prepend(nodes :: LIST? OF STRING?, bucket :: STRING?, documentId :: STRING?, json :: STRING?) :: (id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?, content :: MAP?)",
        "apoc.couchbase.prepend(nodes, bucket, documentId, jsonDocument) yield id, expiry, cas, mutationToken, content - prepend a couchbase json document to an existing one.",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.couchbase.query",
        "apoc.couchbase.query(nodes :: LIST? OF STRING?, bucket :: STRING?, statement :: STRING?) :: (queryResult :: LIST? OF MAP?)",
        "apoc.couchbase.query(nodes, bucket, statement) yield queryResult - executes a plain un-parameterized N1QL statement.",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.couchbase.remove",
        "apoc.couchbase.remove(nodes :: LIST? OF STRING?, bucket :: STRING?, documentId :: STRING?) :: (id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?, content :: MAP?)",
        "apoc.couchbase.remove(nodes, bucket, documentId) yield id, expiry, cas, mutationToken, content - remove the couchbase json document identified by its unique ID.",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.couchbase.replace",
        "apoc.couchbase.replace(nodes :: LIST? OF STRING?, bucket :: STRING?, documentId :: STRING?, json :: STRING?) :: (id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?, content :: MAP?)",
        "apoc.couchbase.replace(nodes, bucket, documentId, jsonDocument) yield id, expiry, cas, mutationToken, content - replace the content of the couchbase json document identified by its unique ID.",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.couchbase.upsert",
        "apoc.couchbase.upsert(nodes :: LIST? OF STRING?, bucket :: STRING?, documentId :: STRING?, json :: STRING?) :: (id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?, content :: MAP?)",
        "apoc.couchbase.upsert(nodes, bucket, documentId, jsonDocument) yield id, expiry, cas, mutationToken, content - insert or overwrite a couchbase json document with its unique ID.",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.create.addLabels",
        "apoc.create.addLabels(nodes :: ANY?, label :: LIST? OF STRING?) :: (node :: NODE?)",
        "apoc.create.addLabels( [node,id,ids,nodes], ['Label',...]) - adds the given labels to the node or nodes",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.create.node",
        "apoc.create.node(label :: LIST? OF STRING?, props :: MAP?) :: (node :: NODE?)",
        "apoc.create.node(['Label'], {key:value,...}) - create node with dynamic labels",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.create.nodes",
        "apoc.create.nodes(label :: LIST? OF STRING?, props :: LIST? OF MAP?) :: (node :: NODE?)",
        "apoc.create.nodes(['Label'], [{key:value,...}]) create multiple nodes with dynamic labels",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.create.relationship",
        "apoc.create.relationship(from :: NODE?, relType :: STRING?, props :: MAP?, to :: NODE?) :: (rel :: RELATIONSHIP?)",
        "apoc.create.relationship(person1,'KNOWS',{key:value,...}, person2) create relationship with dynamic rel-type",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.create.removeLabels",
        "apoc.create.removeLabels(nodes :: ANY?, label :: LIST? OF STRING?) :: (node :: NODE?)",
        "apoc.create.removeLabels( [node,id,ids,nodes], ['Label',...]) - removes the given labels from the node or nodes",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.create.setLabels",
        "apoc.create.setLabels(nodes :: ANY?, label :: LIST? OF STRING?) :: (node :: NODE?)",
        "apoc.create.setLabels( [node,id,ids,nodes], ['Label',...]) - sets the given labels, non matching labels are removed on the node or nodes",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.create.setProperties",
        "apoc.create.setProperties(nodes :: ANY?, keys :: LIST? OF STRING?, values :: LIST? OF ANY?) :: (node :: NODE?)",
        "apoc.create.setProperties( [node,id,ids,nodes], [keys], [values]) - sets the given property on the nodes(s)",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.create.setProperty",
        "apoc.create.setProperty(nodes :: ANY?, key :: STRING?, value :: ANY?) :: (node :: NODE?)",
        "apoc.create.setProperty( [node,id,ids,nodes], key, value) - sets the given property on the node(s)",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.create.setRelProperties",
        "apoc.create.setRelProperties(rels :: ANY?, keys :: LIST? OF STRING?, values :: LIST? OF ANY?) :: (rel :: RELATIONSHIP?)",
        "apoc.create.setRelProperties( [rel,id,ids,rels], [keys], [values]) - sets the given property on the relationship(s)",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.create.setRelProperty",
        "apoc.create.setRelProperty(relationships :: ANY?, key :: STRING?, value :: ANY?) :: (rel :: RELATIONSHIP?)",
        "apoc.create.setRelProperty( [rel,id,ids,rels], key, value) - sets the given property on the relationship(s)",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.create.uuids",
        "apoc.create.uuids(count :: INTEGER?) :: (row :: INTEGER?, uuid :: STRING?)",
        "apoc.create.uuids(count) yield uuid - creates 'count' UUIDs ",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.create.vNode",
        "apoc.create.vNode(label :: LIST? OF STRING?, props :: MAP?) :: (node :: NODE?)",
        "apoc.create.vNode(['Label'], {key:value,...}) returns a virtual node",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.create.vNodes",
        "apoc.create.vNodes(label :: LIST? OF STRING?, props :: LIST? OF MAP?) :: (node :: NODE?)",
        "apoc.create.vNodes(['Label'], [{key:value,...}]) returns virtual nodes",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.create.vPattern",
        "apoc.create.vPattern(from :: MAP?, relType :: STRING?, props :: MAP?, to :: MAP?) :: (from :: NODE?, rel :: RELATIONSHIP?, to :: NODE?)",
        "apoc.create.vPattern({_labels:['LabelA'],key:value},'KNOWS',{key:value,...}, {_labels:['LabelB'],key:value}) returns a virtual pattern",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.create.vPatternFull",
        "apoc.create.vPatternFull(labelsN :: LIST? OF STRING?, n :: MAP?, relType :: STRING?, props :: MAP?, labelsM :: LIST? OF STRING?, m :: MAP?) :: (from :: NODE?, rel :: RELATIONSHIP?, to :: NODE?)",
        "apoc.create.vPatternFull(['LabelA'],{key:value},'KNOWS',{key:value,...},['LabelB'],{key:value}) returns a virtual pattern",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.create.vRelationship",
        "apoc.create.vRelationship(from :: NODE?, relType :: STRING?, props :: MAP?, to :: NODE?) :: (rel :: RELATIONSHIP?)",
        "apoc.create.vRelationship(nodeFrom,'KNOWS',{key:value,...}, nodeTo) returns a virtual relationship",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.cypher.doit",
        "apoc.cypher.doit(cypher :: STRING?, params :: MAP?) :: (value :: MAP?)",
        "apoc.cypher.doIt(fragment, params) yield value - executes writing fragment with the given parameters",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.cypher.mapParallel",
        "apoc.cypher.mapParallel(fragment :: STRING?, params :: MAP?, list :: LIST? OF ANY?) :: (value :: MAP?)",
        "apoc.cypher.mapParallel(fragment, params, list-to-parallelize) yield value - executes fragment in parallel batches with the list segments being assigned to _",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.cypher.mapParallel2",
        "apoc.cypher.mapParallel2(fragment :: STRING?, params :: MAP?, list :: LIST? OF ANY?, partitions :: INTEGER?) :: (value :: MAP?)",
        "apoc.cypher.mapParallel2(fragment, params, list-to-parallelize) yield value - executes fragment in parallel batches with the list segments being assigned to _",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.cypher.parallel",
        "apoc.cypher.parallel(fragment :: STRING?, params :: MAP?, parallelizeOn :: STRING?) :: (value :: MAP?)",
        "",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.cypher.parallel2",
        "apoc.cypher.parallel2(fragment :: STRING?, params :: MAP?, parallelizeOn :: STRING?) :: (value :: MAP?)",
        "",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.cypher.run",
        "apoc.cypher.run(cypher :: STRING?, params :: MAP?) :: (value :: MAP?)",
        "apoc.cypher.run(fragment, params) yield value - executes reading fragment with the given parameters",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.cypher.runFile",
        "apoc.cypher.runFile(file :: STRING?) :: (row :: INTEGER?, result :: MAP?)",
        "apoc.cypher.runFile(file or url) - runs each statement in the file, all semicolon separated - currently no schema operations",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.cypher.runMany",
        "apoc.cypher.runMany(cypher :: STRING?, params :: MAP?) :: (row :: INTEGER?, result :: MAP?)",
        "apoc.cypher.runMany('cypher;\\nstatements;',{params}) - runs each semicolon separated statement and returns summary - currently no schema operations",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.cypher.runTimeboxed",
        "apoc.cypher.runTimeboxed(cypher :: STRING?, params :: MAP?, timeout :: INTEGER?) :: (value :: MAP?)",
        "apoc.cypher.runTimeboxed('cypherStatement',{params}, timeout) - abort statement after timeout ms if not finished",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.date.expire",
        "apoc.date.expire(node :: NODE?, time :: INTEGER?, timeUnit :: STRING?) :: VOID",
        "CALL apoc.date.expire(node,time,'time-unit') - expire node in given time by setting :TTL label and `ttl` property",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.date.expireIn",
        "apoc.date.expireIn(node :: NODE?, timeDelta :: INTEGER?, timeUnit :: STRING?) :: VOID",
        "CALL apoc.date.expire.in(node,time,'time-unit') - expire node in given time-delta by setting :TTL label and `ttl` property",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.es.get",
        "apoc.es.get(host :: STRING?, index :: STRING?, type :: STRING?, id :: STRING?, query :: ANY?, payload :: ANY?) :: (value :: MAP?)",
        "apoc.es.get(host-or-port,index-or-null,type-or-null,id-or-null,query-or-null,payload-or-null) yield value - perform a GET operation on elastic search",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.es.getRaw",
        "apoc.es.getRaw(host :: STRING?, path :: STRING?, payload :: ANY?) :: (value :: MAP?)",
        "apoc.es.getRaw(host-or-port,path,payload-or-null) yield value - perform a raw GET operation on elastic search",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.es.post",
        "apoc.es.post(host :: STRING?, index :: STRING?, type :: STRING?, id :: STRING?, query :: ANY?, payload :: ANY?) :: (value :: MAP?)",
        "apoc.es.post(host-or-port,index-or-null,type-or-null,query-or-null,payload-or-null) yield value - perform a POST operation on elastic search",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.es.postRaw",
        "apoc.es.postRaw(host :: STRING?, path :: STRING?, payload :: ANY?) :: (value :: MAP?)",
        "apoc.es.postRaw(host-or-port,path,payload-or-null) yield value - perform a raw POST operation on elastic search",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.es.put",
        "apoc.es.put(host :: STRING?, index :: STRING?, type :: STRING?, id :: STRING?, query :: ANY?, payload :: ANY?) :: (value :: MAP?)",
        "apoc.es.put(host-or-port,index-or-null,type-or-null,query-or-null,payload-or-null) yield value - perform a PUT operation on elastic search",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.es.query",
        "apoc.es.query(host :: STRING?, index :: STRING?, type :: STRING?, query :: ANY?, payload :: ANY?) :: (value :: MAP?)",
        "apoc.es.query(host-or-port,index-or-null,type-or-null,query-or-null,payload-or-null) yield value - perform a SEARCH operation on elastic search",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.es.stats",
        "apoc.es.stats(host :: STRING?) :: (value :: MAP?)",
        "apoc.es.stats(host-url-Key) - elastic search statistics",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.example.movies",
        "apoc.example.movies() :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?)",
        "apoc.example.movies() | Creates the sample movies graph",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.export.csv.all",
        "apoc.export.csv.all(file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?)",
        "",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.export.csv.data",
        "apoc.export.csv.data(nodes :: LIST? OF NODE?, rels :: LIST? OF RELATIONSHIP?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?)",
        "",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.export.csv.graph",
        "apoc.export.csv.graph(graph :: MAP?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?)",
        "",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.export.csv.query",
        "apoc.export.csv.query(query :: STRING?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?)",
        "",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.export.cypher.all",
        "apoc.export.cypher.all(file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?)",
        "apoc.export.cypher.all(file,config) - exports whole database incl. indexes as cypher statements to the provided file",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.export.cypher.data",
        "apoc.export.cypher.data(nodes :: LIST? OF NODE?, rels :: LIST? OF RELATIONSHIP?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?)",
        "apoc.export.cypher.data(nodes,rels,file,config) - exports given nodes and relationships incl. indexes as cypher statements to the provided file",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.export.cypher.graph",
        "apoc.export.cypher.graph(graph :: MAP?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?)",
        "apoc.export.cypher.graph(graph,file,config) - exports given graph object incl. indexes as cypher statements to the provided file",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.export.cypher.query",
        "apoc.export.cypher.query(query :: STRING?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?)",
        "apoc.export.cypher.query(query,file,config) - exports nodes and relationships from the cypher statement incl. indexes as cypher statements to the provided file",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.export.cypherAll",
        "apoc.export.cypherAll(file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?)",
        "apoc.export.cypherAll(file,config) - exports whole database incl. indexes as cypher statements to the provided file",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.export.cypherData",
        "apoc.export.cypherData(nodes :: LIST? OF NODE?, rels :: LIST? OF RELATIONSHIP?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?)",
        "apoc.export.cypherData(nodes,rels,file,config) - exports given nodes and relationships incl. indexes as cypher statements to the provided file",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.export.cypherGraph",
        "apoc.export.cypherGraph(graph :: MAP?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?)",
        "apoc.export.cypherGraph(graph,file,config) - exports given graph object incl. indexes as cypher statements to the provided file",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.export.cypherQuery",
        "apoc.export.cypherQuery(query :: STRING?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?)",
        "apoc.export.cypherQuery(query,file,config) - exports nodes and relationships from the cypher statement incl. indexes as cypher statements to the provided file",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.export.graphml.all",
        "apoc.export.graphml.all(file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?)",
        "apoc.export.graphml.all(file,config) - exports whole database as graphml to the provided file",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.export.graphml.data",
        "apoc.export.graphml.data(nodes :: LIST? OF NODE?, rels :: LIST? OF RELATIONSHIP?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?)",
        "apoc.export.graphml.data(nodes,rels,file,config) - exports given nodes and relationships as graphml to the provided file",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.export.graphml.graph",
        "apoc.export.graphml.graph(graph :: MAP?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?)",
        "apoc.export.graphml.graph(graph,file,config) - exports given graph object as graphml to the provided file",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.export.graphml.query",
        "apoc.export.graphml.query(query :: STRING?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?)",
        "apoc.export.graphml.query(query,file,config) - exports nodes and relationships from the cypher statement as graphml to the provided file",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.generate.ba",
        "apoc.generate.ba(noNodes :: INTEGER?, edgesPerNode :: INTEGER?, label :: STRING?, type :: STRING?) :: VOID",
        "apoc.generate.ba(noNodes, edgesPerNode, label, type) - generates a random graph according to the Barabasi-Albert model",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.generate.complete",
        "apoc.generate.complete(noNodes :: INTEGER?, label :: STRING?, type :: STRING?) :: VOID",
        "apoc.generate.complete(noNodes, label, type) - generates a random complete graph",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.generate.er",
        "apoc.generate.er(noNodes :: INTEGER?, noEdges :: INTEGER?, label :: STRING?, type :: STRING?) :: VOID",
        "apoc.generate.er(noNodes, noEdges, label, type) - generates a random graph according to the Erdos-Renyi model",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.generate.simple",
        "apoc.generate.simple(degrees :: LIST? OF INTEGER?, label :: STRING?, type :: STRING?) :: VOID",
        "apoc.generate.simple(degrees, label, type) - generates a simple random graph according to the given degree distribution",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.generate.ws",
        "apoc.generate.ws(noNodes :: INTEGER?, degree :: INTEGER?, beta :: FLOAT?, label :: STRING?, type :: STRING?) :: VOID",
        "apoc.generate.ws(noNodes, degree, beta, label, type) - generates a random graph according to the Watts-Strogatz model",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.gephi.add",
        "apoc.gephi.add(urlOrKey :: STRING?, workspace :: STRING?, data :: ANY?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?)",
        "apoc.gephi.add(url-or-key, workspace, data) | streams passed in data to Gephi",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.get.nodes",
        "apoc.get.nodes(nodes :: ANY?) :: (node :: NODE?)",
        "apoc.get.nodes(node|id|[ids]) - quickly returns all nodes with these id's",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.get.rels",
        "apoc.get.rels(relationships :: ANY?) :: (rel :: RELATIONSHIP?)",
        "apoc.get.rels(rel|id|[ids]) - quickly returns all relationships with these id's",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.graph.from",
        "apoc.graph.from(data :: ANY?, name :: STRING?, properties :: MAP?) :: (graph :: MAP?)",
        "apoc.graph.from(data,'name',{properties}) | creates a virtual graph object for later processing it tries its best to extract the graph information from the data you pass in",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.graph.fromCypher",
        "apoc.graph.fromCypher(statement :: STRING?, params :: MAP?, name :: STRING?, properties :: MAP?) :: (graph :: MAP?)",
        "apoc.graph.fromCypher('statement',{params},'name',{properties}) - creates a virtual graph object for later processing",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.graph.fromDB",
        "apoc.graph.fromDB(name :: STRING?, properties :: MAP?) :: (graph :: MAP?)",
        "apoc.graph.fromDB('name',{properties}) - creates a virtual graph object for later processing",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.graph.fromData",
        "apoc.graph.fromData(nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?, name :: STRING?, properties :: MAP?) :: (graph :: MAP?)",
        "apoc.graph.fromData([nodes],[relationships],'name',{properties}) | creates a virtual graph object for later processing",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.graph.fromPath",
        "apoc.graph.fromPath(path :: PATH?, name :: STRING?, properties :: MAP?) :: (graph :: MAP?)",
        "apoc.graph.fromPaths(path,'name',{properties}) - creates a virtual graph object for later processing",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.graph.fromPaths",
        "apoc.graph.fromPaths(paths :: LIST? OF PATH?, name :: STRING?, properties :: MAP?) :: (graph :: MAP?)",
        "apoc.graph.fromPaths([paths],'name',{properties}) - creates a virtual graph object for later processing",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.help",
        "apoc.help(proc :: STRING?) :: (type :: STRING?, name :: STRING?, text :: STRING?, signature :: STRING?, roles :: LIST? OF STRING?, writes :: BOOLEAN?)",
        "Provides descriptions of available procedures. To narrow the results, supply a search string. To also search in the description text, append + to the end of the search string.",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.import.graphml",
        "apoc.import.graphml(file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?)",
        "apoc.import.graphml(file,config) - imports graphml file",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.index.addAllNodes",
        "apoc.index.addAllNodes(index :: STRING?, structure :: MAP?) :: (label :: STRING?, property :: STRING?, nodeCount :: INTEGER?)",
        "apoc.index.addAllNodes('name',{label1:['prop1',...],...}) YIELD type, name, config - create a free text search index",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.index.addAllNodesExtended",
        "apoc.index.addAllNodesExtended(index :: STRING?, structure :: MAP?, options :: MAP?) :: (label :: STRING?, property :: STRING?, nodeCount :: INTEGER?)",
        "apoc.index.addAllNodes('name',{label1:['prop1',...],...}, {options}) YIELD type, name, config - create a free text search index with special options",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.index.addNode",
        "apoc.index.addNode(node :: NODE?, properties :: LIST? OF STRING?) :: VOID",
        "apoc.index.addNode(node,['prop1',...]) add node to an index for each label it has",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.index.addNodeByLabel",
        "apoc.index.addNodeByLabel(label :: STRING?, node :: NODE?, properties :: LIST? OF STRING?) :: VOID",
        "apoc.index.addNodeByLabel(node,'Label',['prop1',...]) add node to an index for the given label",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.index.addRelationship",
        "apoc.index.addRelationship(relationship :: RELATIONSHIP?, properties :: LIST? OF STRING?) :: VOID",
        "apoc.index.addRelationship(rel,['prop1',...]) add relationship to an index for its type",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.index.between",
        "apoc.index.between(from :: NODE?, type :: STRING?, to :: NODE?, query :: STRING?) :: (rel :: RELATIONSHIP?, weight :: FLOAT?, start :: NODE?, end :: NODE?)",
        "apoc.index.between(node1,'TYPE',node2,'prop:value*') YIELD rel - lucene query on relationship index with the given type name bound by either or both sides (each node parameter can be null)",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.index.forNodes",
        "apoc.index.forNodes(name :: STRING?, config :: MAP?) :: (type :: STRING?, name :: STRING?, config :: MAP?)",
        "apoc.index.forNodes('name',{config}) YIELD type,name,config - gets or creates node index",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.index.forRelationships",
        "apoc.index.forRelationships(name :: STRING?, config :: MAP?) :: (type :: STRING?, name :: STRING?, config :: MAP?)",
        "apoc.index.forRelationships('name',{config}) YIELD type,name,config - gets or creates relationship index",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.index.in",
        "apoc.index.in(to :: NODE?, type :: STRING?, query :: STRING?) :: (node :: NODE?, weight :: FLOAT?)",
        "apoc.index.in(node,'TYPE','prop:value*') YIELD node lucene query on relationship index with the given type name for *incoming* relationship of the given node, *returns start-nodes*",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.index.list",
        "apoc.index.list() :: (type :: STRING?, name :: STRING?, config :: MAP?)",
        "apoc.index.list() - YIELD type,name,config - lists all manual indexes",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.index.nodes",
        "apoc.index.nodes(label :: STRING?, query :: STRING?) :: (node :: NODE?, weight :: FLOAT?)",
        "apoc.index.nodes('Label','prop:value*') YIELD node - lucene query on node index with the given label name",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.index.orderedByText",
        "apoc.index.orderedByText(label :: STRING?, key :: STRING?, operator :: STRING?, value :: STRING?, relevance :: BOOLEAN?, limit :: INTEGER?) :: (node :: NODE?)",
        "apoc.index.orderedByText(label,key,operator,value,sort-relevance,limit) yield node - schema string search which keeps index order and adds limit, operator is 'STARTS WITH' or 'CONTAINS'",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.index.orderedRange",
        "apoc.index.orderedRange(label :: STRING?, key :: STRING?, min :: ANY?, max :: ANY?, relevance :: BOOLEAN?, limit :: INTEGER?) :: (node :: NODE?)",
        "apoc.index.orderedRange(label,key,min,max,sort-relevance,limit) yield node - schema range scan which keeps index order and adds limit, values can be null, boundaries are inclusive",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.index.out",
        "apoc.index.out(from :: NODE?, type :: STRING?, query :: STRING?) :: (node :: NODE?, weight :: FLOAT?)",
        "apoc.index.out(node,'TYPE','prop:value*') YIELD node - lucene query on relationship index with the given type name for *outgoing* relationship of the given node, *returns end-nodes*",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.index.related",
        "apoc.index.related(nodes :: LIST? OF NODE?, label :: STRING?, key :: STRING?, relationship :: STRING?, limit :: INTEGER?) :: (node :: NODE?)",
        "apoc.index.relatedNodes([nodes],label,key,'<TYPE'/'TYPE>'/'TYPE',limit) yield node - schema range scan which keeps index order and adds limit and checks opposite node of relationship against the given set of nodes",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.index.relationships",
        "apoc.index.relationships(type :: STRING?, query :: STRING?) :: (rel :: RELATIONSHIP?, weight :: FLOAT?, start :: NODE?, end :: NODE?)",
        "apoc.index.relationships('TYPE','prop:value*') YIELD rel - lucene query on relationship index with the given type name",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.index.remove",
        "apoc.index.remove(name :: STRING?) :: (type :: STRING?, name :: STRING?, config :: MAP?)",
        "apoc.index.remove('name') YIELD type,name,config - removes an manual index",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.index.search",
        "apoc.index.search(index :: STRING?, query :: STRING?) :: (node :: NODE?, weight :: FLOAT?)",
        "apoc.index.search('name', 'query') YIELD node, weight - search for nodes in the free text index matching the given query",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.load.csv",
        "apoc.load.csv(url :: STRING?, config :: MAP?) :: (lineNo :: INTEGER?, list :: LIST? OF ANY?, map :: MAP?)",
        "apoc.load.csv('url',{config}) YIELD lineNo, list, map - load CSV fom URL as stream of values,\n config contains any of: {skip:1,limit:5,header:false,sep:'TAB',ignore:['tmp'],arraySep:';',mapping:{years:{type:'int',arraySep:'-',array:false,name:'age',ignore:false}}",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.load.driver",
        "apoc.load.driver(driverClass :: STRING?) :: VOID",
        "apoc.load.driver('org.apache.derby.jdbc.EmbeddedDriver') register JDBC driver of source database",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.load.jdbc",
        "apoc.load.jdbc(jdbc :: STRING?, tableOrSql :: STRING?) :: (row :: MAP?)",
        "apoc.load.jdbc('key or url','table or statement') YIELD row - load from relational database, from a full table or a sql statement",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.load.jdbcParams",
        "apoc.load.jdbcParams(jdbc :: STRING?, sql :: STRING?, params :: LIST? OF ANY?) :: (row :: MAP?)",
        "apoc.load.jdbcParams('key or url','statement',[params]) YIELD row - load from relational database, from a sql statement with parameters",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.load.json",
        "apoc.load.json(url :: STRING?) :: (value :: MAP?)",
        "apoc.load.json('url') YIELD value -  import JSON as stream of values if the JSON was an array or a single value if it was a map",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.load.jsonArray",
        "apoc.load.jsonArray(url :: STRING?) :: (value :: ANY?)",
        "apoc.load.jsonArray('url') YIELD value - load array from JSON URL (e.g. web-api) to import JSON as stream of values",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.load.jsonParams",
        "apoc.load.jsonParams(url :: STRING?, headers :: MAP?, payload :: STRING?) :: (value :: MAP?)",
        "apoc.load.jsonParams('url',{header:value},payload) YIELD value - load from JSON URL (e.g. web-api) while sending headers / payload to import JSON as stream of values if the JSON was an array or a single value if it was a map",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.load.xml",
        "apoc.load.xml(url :: STRING?) :: (value :: MAP?)",
        "apoc.load.xml('http://example.com/test.xml') YIELD value as doc CREATE (p:Person) SET p.name = doc.name load from XML URL (e.g. web-api) to import XML as single nested map with attributes and _type, _text and _childrenx fields.",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.load.xmlSimple",
        "apoc.load.xmlSimple(url :: STRING?) :: (value :: MAP?)",
        "apoc.load.xml('http://example.com/test.xml') YIELD value as doc CREATE (p:Person) SET p.name = doc.name load from XML URL (e.g. web-api) to import XML as single nested map with attributes and _type, _text and _childrenx fields.",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.lock.all",
        "apoc.lock.all(nodes :: LIST? OF NODE?, rels :: LIST? OF RELATIONSHIP?) :: VOID",
        "apoc.lock.all([nodes],[relationships]) acquires a write lock on the given nodes and relationships",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.lock.nodes",
        "apoc.lock.nodes(nodes :: LIST? OF NODE?) :: VOID",
        "apoc.lock.nodes([nodes]) acquires a write lock on the given nodes",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.lock.rels",
        "apoc.lock.rels(rels :: LIST? OF RELATIONSHIP?) :: VOID",
        "apoc.lock.rels([relationships]) acquires a write lock on the given relationship",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.meta.data",
        "apoc.meta.data() :: (label :: STRING?, property :: STRING?, count :: INTEGER?, unique :: BOOLEAN?, index :: BOOLEAN?, existence :: BOOLEAN?, type :: STRING?, array :: BOOLEAN?, sample :: LIST? OF ANY?, leftCount :: INTEGER?, rightCount :: INTEGER?, left :: INTEGER?, right :: INTEGER?, other :: LIST? OF STRING?)",
        "apoc.meta.data  - examines a subset of the graph to provide a tabular meta information",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.meta.graph",
        "apoc.meta.graph() :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)",
        "apoc.meta.graph - examines the full graph to create the meta-graph",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.meta.graphSample",
        "apoc.meta.graphSample() :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)",
        "apoc.meta.graphSample() - examines the database statistics to build the meta graph, very fast, might report extra relationships",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.meta.stats",
        "apoc.meta.stats() :: (labelCount :: INTEGER?, relTypeCount :: INTEGER?, propertyKeyCount :: INTEGER?, nodeCount :: INTEGER?, relCount :: INTEGER?, labels :: MAP?, relTypes :: MAP?, stats :: MAP?)",
        "apoc.meta.stats  yield labelCount, relTypeCount, propertyKeyCount, nodeCount, relCount, labels, relTypes, stats | returns the information stored in the transactional database statistics",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.meta.subGraph",
        "apoc.meta.subGraph(config :: MAP?) :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)",
        "apoc.meta.subGraph({labels:[labels],rels:[rel-types], excludes:[labels,rel-types]}) - examines a sample sub graph to create the meta-graph",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.mongodb.count",
        "apoc.mongodb.count(host :: STRING?, db :: STRING?, collection :: STRING?, query :: MAP?) :: (value :: INTEGER?)",
        "apoc.mongodb.count(host-or-port,db-or-null,collection-or-null,query-or-null) yield value - perform a find operation on mongodb collection",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.mongodb.delete",
        "apoc.mongodb.delete(host :: STRING?, db :: STRING?, collection :: STRING?, query :: MAP?) :: (value :: INTEGER?)",
        "apoc.mongodb.delete(host-or-port,db-or-null,collection-or-null,list-of-maps) - inserts the given documents into the mongodb collection",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.mongodb.find",
        "apoc.mongodb.find(host :: STRING?, db :: STRING?, collection :: STRING?, query :: MAP?, project :: MAP?, sort :: MAP?) :: (value :: MAP?)",
        "apoc.mongodb.find(host-or-port,db-or-null,collection-or-null,query-or-null,projection-or-null,sort-or-null) yield value - perform a find,project,sort operation on mongodb collection",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.mongodb.first",
        "apoc.mongodb.first(host :: STRING?, db :: STRING?, collection :: STRING?, query :: MAP?) :: (value :: MAP?)",
        "apoc.mongodb.first(host-or-port,db-or-null,collection-or-null,query-or-null) yield value - perform a first operation on mongodb collection",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.mongodb.get",
        "apoc.mongodb.get(host :: STRING?, db :: STRING?, collection :: STRING?, query :: MAP?) :: (value :: MAP?)",
        "apoc.mongodb.get(host-or-port,db-or-null,collection-or-null,query-or-null) yield value - perform a find operation on mongodb collection",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.mongodb.insert",
        "apoc.mongodb.insert(host :: STRING?, db :: STRING?, collection :: STRING?, documents :: LIST? OF MAP?) :: VOID",
        "apoc.mongodb.insert(host-or-port,db-or-null,collection-or-null,list-of-maps) - inserts the given documents into the mongodb collection",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.mongodb.update",
        "apoc.mongodb.update(host :: STRING?, db :: STRING?, collection :: STRING?, query :: MAP?, update :: MAP?) :: (value :: INTEGER?)",
        "apoc.mongodb.update(host-or-port,db-or-null,collection-or-null,list-of-maps) - inserts the given documents into the mongodb collection",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.monitor.ids",
        "apoc.monitor.ids() :: (nodeIds :: INTEGER?, relIds :: INTEGER?, propIds :: INTEGER?, relTypeIds :: INTEGER?)",
        "apoc.monitor.ids() returns the object ids in use for this neo4j instance",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.monitor.kernel",
        "apoc.monitor.kernel() :: (readOnly :: BOOLEAN?, kernelVersion :: STRING?, storeId :: STRING?, kernelStartTime :: STRING?, databaseName :: STRING?, storeLogVersion :: INTEGER?, storeCreationDate :: STRING?)",
        "apoc.monitor.kernel() returns informations about the neo4j kernel",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.monitor.locks",
        "apoc.monitor.locks(minWaitTime :: INTEGER?) :: (advertedDeadLocks :: INTEGER?, lockCount :: INTEGER?, contendedLockCount :: INTEGER?, minimumWaitTimeMs :: INTEGER?, contendedLocks :: LIST? OF MAP?, info :: STRING?)",
        "apoc.monitor.locks(minWaitTime) yield advertedDeadLocks, lockCount, contendedLockCount, minimumWaitTimeMs, contendedLocks, info",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.monitor.store",
        "apoc.monitor.store() :: (logSize :: INTEGER?, stringStoreSize :: INTEGER?, arrayStoreSize :: INTEGER?, relStoreSize :: INTEGER?, propStoreSize :: INTEGER?, totalStoreSize :: INTEGER?, nodeStoreSize :: INTEGER?)",
        "apoc.monitor.store() returns informations about the sizes of the different parts of the neo4j graph store",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.monitor.tx",
        "apoc.monitor.tx() :: (rolledBackTx :: INTEGER?, peakTx :: INTEGER?, lastTxId :: INTEGER?, currentOpenedTx :: INTEGER?, totalOpenedTx :: INTEGER?, totalTx :: INTEGER?)",
        "apoc.monitor.tx() returns informations about the neo4j transaction manager",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.nodes.delete",
        "apoc.nodes.delete(nodes :: ANY?, batchSize :: INTEGER?) :: (value :: INTEGER?)",
        "apoc.nodes.delete(node|nodes|id|[ids]) - quickly delete all nodes with these id's",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.nodes.get",
        "apoc.nodes.get(nodes :: ANY?) :: (node :: NODE?)",
        "apoc.nodes.get(node|nodes|id|[ids]) - quickly returns all nodes with these id's",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.nodes.link",
        "apoc.nodes.link(nodes :: LIST? OF NODE?, type :: STRING?) :: VOID",
        "apoc.nodes.link([nodes],'REL_TYPE') - creates a linked list of nodes from first to last",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.nodes.rels",
        "apoc.nodes.rels(relationships :: ANY?) :: (rel :: RELATIONSHIP?)",
        "apoc.get.rels(rel|id|[ids]) - quickly returns all relationships with these id's",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.path.expand",
        "apoc.path.expand(start :: ANY?, relationshipFilter :: STRING?, labelFilter :: STRING?, minLevel :: INTEGER?, maxLevel :: INTEGER?) :: (path :: PATH?)",
        "apoc.path.expand(startNode <id>|Node|list, 'TYPE|TYPE_OUT>|<TYPE_IN', '+YesLabel|-NoLabel', minLevel, maxLevel ) yield path expand from start node following the given relationships from min to max-level adhering to the label filters",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.path.expandConfig",
        "apoc.path.expandConfig(start :: ANY?, config :: MAP?) :: (path :: PATH?)",
        "apoc.path.expandConfig(startNode <id>|Node|list, {minLevel,maxLevel,uniqueness,relationshipFilter,labelFilter,uniqueness:'RELATIONSHIP_PATH',bfs:true}) yield path expand from start node following the given relationships from min to max-level adhering to the label filters",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.periodic.cancel",
        "apoc.periodic.cancel(name :: STRING?) :: (name :: STRING?, delay :: INTEGER?, rate :: INTEGER?, done :: BOOLEAN?, cancelled :: BOOLEAN?)",
        "apoc.periodic.cancel(name) - cancel job with the given name",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.periodic.commit",
        "apoc.periodic.commit(statement :: STRING?, params :: MAP?) :: (updates :: INTEGER?, executions :: INTEGER?, runtime :: INTEGER?, batches :: INTEGER?, faileBatches :: INTEGER?, batchErrors :: MAP?, failedCommits :: INTEGER?, commitErrors :: MAP?)",
        "apoc.periodic.commit(statement,params) - runs the given statement in separate transactions until it returns 0",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.periodic.iterate",
        "apoc.periodic.iterate(cypherIterate :: STRING?, cypherAction :: STRING?, config :: MAP?) :: (batches :: INTEGER?, total :: INTEGER?, timeTaken :: INTEGER?, committedOperations :: INTEGER?, failedOperations :: INTEGER?, failedBatches :: INTEGER?, errorMessages :: MAP?, batch :: MAP?, operations :: MAP?)",
        "apoc.periodic.iterate('statement returning items', 'statement per item', {batchSize:1000,parallel:true}) YIELD batches, total - run the second statement for each item returned by the first statement. Returns number of batches and total processed rows",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.periodic.list",
        "apoc.periodic.list() :: (name :: STRING?, delay :: INTEGER?, rate :: INTEGER?, done :: BOOLEAN?, cancelled :: BOOLEAN?)",
        "apoc.periodic.list - list all jobs",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.periodic.repeat",
        "apoc.periodic.repeat(name :: STRING?, statement :: STRING?, rate :: INTEGER?) :: (name :: STRING?, delay :: INTEGER?, rate :: INTEGER?, done :: BOOLEAN?, cancelled :: BOOLEAN?)",
        "apoc.periodic.schedule('name',statement,repeat-time-in-seconds) submit a repeatedly-called background statement",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.periodic.rock_n_roll",
        "apoc.periodic.rock_n_roll(cypherIterate :: STRING?, cypherAction :: STRING?, batchSize :: INTEGER?) :: (batches :: INTEGER?, total :: INTEGER?, timeTaken :: INTEGER?, committedOperations :: INTEGER?, failedOperations :: INTEGER?, failedBatches :: INTEGER?, errorMessages :: MAP?, batch :: MAP?, operations :: MAP?)",
        "apoc.periodic.rock_n_roll('some cypher for iteration', 'some cypher as action on each iteration', 10000) YIELD batches, total - run the action statement in batches over the iterator statement's results in a separate thread. Returns number of batches and total processed rows",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.periodic.rock_n_roll_while",
        "apoc.periodic.rock_n_roll_while(cypherLoop :: STRING?, cypherIterate :: STRING?, cypherAction :: STRING?, batchSize :: INTEGER?) :: (loop :: ANY?, batches :: INTEGER?, total :: INTEGER?)",
        "apoc.periodic.rock_n_roll_while('some cypher for knowing when to stop', 'some cypher for iteration', 'some cypher as action on each iteration', 10000) YIELD batches, total - run the action statement in batches over the iterator statement's results in a separate thread. Returns number of batches and total processed rows",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.periodic.submit",
        "apoc.periodic.submit(name :: STRING?, statement :: STRING?) :: (name :: STRING?, delay :: INTEGER?, rate :: INTEGER?, done :: BOOLEAN?, cancelled :: BOOLEAN?)",
        "apoc.periodic.submit('name',statement) - submit a one-off background statement",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.refactor.categorize",
        "apoc.refactor.categorize(sourceKey :: STRING?, type :: STRING?, outgoing :: BOOLEAN?, label :: STRING?, targetKey :: STRING?, copiedKeys :: LIST? OF STRING?, batchSize :: INTEGER?) :: VOID",
        "apoc.refactor.categorize(sourceKey, type, outgoing, label, targetKey, copiedKeys, batchSize) turn each unique propertyKey into a category node and connect to it",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.refactor.cloneNodes",
        "apoc.refactor.cloneNodes(nodes :: LIST? OF NODE?) :: (input :: INTEGER?, output :: NODE?, error :: STRING?)",
        "apoc.refactor.cloneNodes([node1,node2,...]) clone nodes with their labels and properties",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.refactor.cloneNodesWithRelationships",
        "apoc.refactor.cloneNodesWithRelationships(nodes :: LIST? OF NODE?) :: (input :: INTEGER?, output :: NODE?, error :: STRING?)",
        "apoc.refactor.cloneNodesWithRelationships([node1,node2,...]) clone nodes with their labels, properties and relationships",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.refactor.collapseNode",
        "apoc.refactor.collapseNode(nodes :: ANY?, type :: STRING?) :: (input :: INTEGER?, output :: RELATIONSHIP?, error :: STRING?)",
        "apoc.refactor.collapseNode([node1,node2],'TYPE') collapse node to relationship, node with one rel becomes self-relationship",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.refactor.extractNode",
        "apoc.refactor.extractNode(relationships :: ANY?, labels :: LIST? OF STRING?, outType :: STRING?, inType :: STRING?) :: (input :: INTEGER?, output :: NODE?, error :: STRING?)",
        "apoc.refactor.extractNode([rel1,rel2,...], [labels],'OUT','IN') extract node from relationships",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.refactor.from",
        "apoc.refactor.from(relationship :: RELATIONSHIP?, newNode :: NODE?) :: (input :: INTEGER?, output :: RELATIONSHIP?, error :: STRING?)",
        "apoc.refactor.from(rel, startNode) redirect relationship to use new start-node",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.refactor.invert",
        "apoc.refactor.invert(relationship :: RELATIONSHIP?) :: (input :: INTEGER?, output :: RELATIONSHIP?, error :: STRING?)",
        "apoc.refactor.invert(rel) inverts relationship direction",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.refactor.mergeNodes",
        "apoc.refactor.mergeNodes(nodes :: LIST? OF NODE?) :: (node :: NODE?)",
        "apoc.refactor.mergeNodes([node1,node2]) merge nodes onto first in list",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.refactor.normalizeAsBoolean",
        "apoc.refactor.normalizeAsBoolean(entity :: ANY?, propertyKey :: STRING?, true_values :: LIST? OF ANY?, false_values :: LIST? OF ANY?) :: VOID",
        "apoc.refactor.normalizeAsBoolean(entity, propertyKey, true_values, false_values) normalize/convert a property to be boolean",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.refactor.setType",
        "apoc.refactor.setType(relationship :: RELATIONSHIP?, newType :: STRING?) :: (input :: INTEGER?, output :: RELATIONSHIP?, error :: STRING?)",
        "apoc.refactor.setType(rel, 'NEW-TYPE') change relationship-type",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.refactor.to",
        "apoc.refactor.to(relationship :: RELATIONSHIP?, newNode :: NODE?) :: (input :: INTEGER?, output :: RELATIONSHIP?, error :: STRING?)",
        "apoc.refactor.to(rel, endNode) redirect relationship to use new end-node",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.schema.assert",
        "apoc.schema.assert(indexes :: MAP?, constraints :: MAP?) :: (label :: STRING?, key :: LIST? OF STRING?, unique :: BOOLEAN?, action :: STRING?)",
        "",
        ["admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.schema.properties.distinct",
        "apoc.schema.properties.distinct(label :: STRING?, key :: STRING?) :: (value :: LIST? OF ANY?)",
        "apoc.schema.properties.distinct(label, key) - quickly returns all distinct values for a given key",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.search.multiSearchReduced",
        "apoc.search.multiSearchReduced(LabelPropertyMap :: ANY?, operator :: STRING?, value :: STRING?) :: (id :: INTEGER?, labels :: LIST? OF STRING?, values :: MAP?)",
        "Do a parallel search over multiple indexes returning a reduced representation of the nodes found: node id, labels and the searched properties. apoc.search.multiSearchReduced( map of label and properties which will be searched upon, operator: EXACT | CONTAINS | STARTS WITH | ENDS WITH, searchValue ). Multiple search results for the same node are merged into one record.",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.search.node",
        "apoc.search.node(LabelPropertyMap :: ANY?, operator :: STRING?, value :: STRING?) :: (node :: NODE?)",
        "Do a parallel search over multiple indexes returning nodes. usage apoc.search.node( map of label and properties which will be searched upon, operator: EXACT | CONTAINS | STARTS WITH | ENDS WITH, searchValue ) returns all the DISTINCT Nodes found in the different searches.",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.search.nodeAll",
        "apoc.search.nodeAll(LabelPropertyMap :: ANY?, operator :: STRING?, value :: STRING?) :: (node :: NODE?)",
        "Do a parallel search over multiple indexes returning nodes. usage apoc.search.nodeAll( map of label and properties which will be searched upon, operator: EXACT | CONTAINS | STARTS WITH | ENDS WITH, searchValue ) returns all the Nodes found in the different searches.",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.search.nodeAllReduced",
        "apoc.search.nodeAllReduced(LabelPropertyMap :: ANY?, operator :: STRING?, value :: ANY?) :: (id :: INTEGER?, labels :: LIST? OF STRING?, values :: MAP?)",
        "Do a parallel search over multiple indexes returning a reduced representation of the nodes found: node id, labels and the searched property. apoc.search.nodeShortAll( map of label and properties which will be searched upon, operator: EXACT / CONTAINS / STARTS WITH | ENDS WITH /= / <> / < / > ..., value ). All 'hits' are returned.",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.search.nodeReduced",
        "apoc.search.nodeReduced(LabelPropertyMap :: ANY?, operator :: STRING?, value :: STRING?) :: (id :: INTEGER?, labels :: LIST? OF STRING?, values :: MAP?)",
        "Do a parallel search over multiple indexes returning a reduced representation of the nodes found: node id, labels and the searched properties. apoc.search.nodeReduced( map of label and properties which will be searched upon, operator: EXACT | CONTAINS | STARTS WITH | ENDS WITH, searchValue ). Multiple search results for the same node are merged into one record.",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.spatial.geocode",
        "apoc.spatial.geocode(location :: STRING?, maxResults :: INTEGER?) :: (location :: MAP?, data :: MAP?, latitude :: FLOAT?, longitude :: FLOAT?, description :: STRING?)",
        "apoc.spatial.geocode('address') YIELD location, latitude, longitude, description, osmData - look up geographic location of address from openstreetmap geocoding service",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.spatial.geocodeOnce",
        "apoc.spatial.geocodeOnce(location :: STRING?) :: (location :: MAP?, data :: MAP?, latitude :: FLOAT?, longitude :: FLOAT?, description :: STRING?)",
        "apoc.spatial.geocodeOnce('address') YIELD location, latitude, longitude, description, osmData - look up geographic location of address from openstreetmap geocoding service",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.spatial.sortByDistance",
        "apoc.spatial.sortByDistance(paths :: LIST? OF PATH?) :: (path :: PATH?, distance :: FLOAT?)",
        "apoc.spatial.sortPathsByDistance(List<Path>) sort the given paths based on the geo informations (lat/long) in ascending order",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.static.get",
        "apoc.static.get(key :: STRING?) :: (value :: ANY?)",
        "apoc.static.get(name) - returns statically stored value from config (apoc.static.<key>) or server lifetime storage",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.static.getAll",
        "apoc.static.getAll(prefix :: STRING?) :: (value :: MAP?)",
        "apoc.static.getAll(prefix) - returns statically stored values from config (apoc.static.<prefix>.*) or server lifetime storage",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.static.list",
        "apoc.static.list(prefix :: STRING?) :: (key :: STRING?, value :: ANY?)",
        "apoc.static.list(prefix) - returns statically stored values from config (apoc.static.<prefix>.*) or server lifetime storage",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.static.set",
        "apoc.static.set(key :: STRING?, value :: ANY?) :: (value :: ANY?)",
        "apoc.static.set(name, value) - stores value under key for server livetime storage, returns previously stored or configured value",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.text.format",
        "apoc.text.format(text :: STRING?, params :: LIST? OF ANY?) :: (value :: STRING?)",
        "apoc.text.format(text,[params]) YIELD value - sprintf format the string with the params given",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.text.lpad",
        "apoc.text.lpad(text :: STRING?, count :: INTEGER?, delim :: STRING?) :: (value :: STRING?)",
        "apoc.text.lpad(text,count,delim) YIELD value - left pad the string to the given width",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.text.phonetic",
        "apoc.text.phonetic(value :: ANY?) :: (value :: STRING?)",
        "apoc.text.phonetic(value) yield value - Compute the US_ENGLISH phonetic soundex encoding of all words of the text value which can be a single string or a list of strings",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.text.phoneticDelta",
        "apoc.text.phoneticDelta(text1 :: STRING?, text2 :: STRING?) :: (phonetic1 :: STRING?, phonetic2 :: STRING?, delta :: INTEGER?)",
        "apoc.text.phoneticDelta(text1, text2) yield phonetic1, phonetic2, delta - Compute the US_ENGLISH soundex character difference between two given strings",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.text.rpad",
        "apoc.text.rpad(text :: STRING?, count :: INTEGER?, delim :: STRING?) :: (value :: STRING?)",
        "apoc.text.rpad(text,count,delim) YIELD value - right pad the string to the given width",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.trigger.add",
        "apoc.trigger.add(name :: STRING?, statement :: STRING?, selector :: MAP?) :: (name :: STRING?, query :: STRING?, selector :: MAP?, installed :: BOOLEAN?)",
        "",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.trigger.list",
        "apoc.trigger.list() :: (name :: STRING?, query :: STRING?, selector :: MAP?, installed :: BOOLEAN?)",
        "",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.trigger.remove",
        "apoc.trigger.remove(name :: STRING?) :: (name :: STRING?, query :: STRING?, selector :: MAP?, installed :: BOOLEAN?)",
        "",
        ["publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.util.sleep",
        "apoc.util.sleep(duration :: INTEGER?) :: VOID",
        "apoc.util.sleep(<duration>) | sleeps for <duration> millis, transaction termination is honored",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "apoc.warmup.run",
        "apoc.warmup.run() :: (pageSize :: INTEGER?, nodesPerPage :: INTEGER?, nodesTotal :: INTEGER?, nodePages :: INTEGER?, nodesTime :: INTEGER?, relsPerPage :: INTEGER?, relsTotal :: INTEGER?, relPages :: INTEGER?, relsTime :: INTEGER?, totalTime :: INTEGER?)",
        "apoc.warmup.run() - quickly loads all nodes and rels into memory by skipping one page at a time",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "db.awaitIndex",
        "db.awaitIndex(index :: STRING?, timeOutSeconds = 300 :: INTEGER?) :: VOID",
        "Wait for an index to come online (for example: CALL db.awaitIndex(\":Person(name)\")).",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "db.constraints",
        "db.constraints() :: (description :: STRING?)",
        "List all constraints in the database.",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "db.indexes",
        "db.indexes() :: (description :: STRING?, state :: STRING?, type :: STRING?)",
        "List all indexes in the database.",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "db.labels",
        "db.labels() :: (label :: STRING?)",
        "List all labels in the database.",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "db.propertyKeys",
        "db.propertyKeys() :: (propertyKey :: STRING?)",
        "List all property keys in the database.",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "db.relationshipTypes",
        "db.relationshipTypes() :: (relationshipType :: STRING?)",
        "List all relationship types in the database.",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "db.resampleIndex",
        "db.resampleIndex(index :: STRING?) :: VOID",
        "Schedule resampling of an index (for example: CALL db.resampleIndex(\":Person(name)\")).",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "db.resampleOutdatedIndexes",
        "db.resampleOutdatedIndexes() :: VOID",
        "Schedule resampling of all outdated indexes.",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "db.schema",
        "db.schema() :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)",
        "Show the schema of the data.",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "dbms.changePassword",
        "dbms.changePassword(password :: STRING?) :: VOID",
        "Change the current user's password. Deprecated by dbms.security.changePassword.",
        ["admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "dbms.components",
        "dbms.components() :: (name :: STRING?, versions :: LIST? OF STRING?, edition :: STRING?)",
        "List DBMS components and their versions.",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "dbms.functions",
        "dbms.functions() :: (name :: STRING?, signature :: STRING?, description :: STRING?, roles :: LIST? OF STRING?)",
        "List all user functions in the DBMS.",
        ["admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "dbms.killQueries",
        "dbms.killQueries(ids :: LIST? OF STRING?) :: (queryId :: STRING?, username :: STRING?)",
        "Kill all transactions executing a query with any of the given query ids.",
        ["admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "dbms.killQuery",
        "dbms.killQuery(id :: STRING?) :: (queryId :: STRING?, username :: STRING?)",
        "Kill all transactions executing the query with the given query id.",
        ["admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "dbms.listQueries",
        "dbms.listQueries() :: (queryId :: STRING?, username :: STRING?, query :: STRING?, parameters :: MAP?, startTime :: STRING?, elapsedTime :: STRING?, connectionDetails :: STRING?, metaData :: MAP?)",
        "List all queries currently executing at this instance that are visible to the user.",
        ["admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "dbms.procedures",
        "dbms.procedures() :: (name :: STRING?, signature :: STRING?, description :: STRING?, roles :: LIST? OF STRING?)",
        "List all procedures in the DBMS.",
        ["admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "dbms.queryJmx",
        "dbms.queryJmx(query :: STRING?) :: (name :: STRING?, description :: STRING?, attributes :: MAP?)",
        "Query JMX management data by domain and name. For instance, \"org.neo4j:*\"",
        ["reader", "publisher", "architect", "admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "dbms.security.activateUser",
        "dbms.security.activateUser(username :: STRING?, requirePasswordChange = true :: BOOLEAN?) :: VOID",
        "Activate a suspended user.",
        ["admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "dbms.security.addRoleToUser",
        "dbms.security.addRoleToUser(roleName :: STRING?, username :: STRING?) :: VOID",
        "Assign a role to the user.",
        ["admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "dbms.security.changePassword",
        "dbms.security.changePassword(password :: STRING?, requirePasswordChange = false :: BOOLEAN?) :: VOID",
        "Change the current user's password.",
        ["admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "dbms.security.changeUserPassword",
        "dbms.security.changeUserPassword(username :: STRING?, newPassword :: STRING?, requirePasswordChange = true :: BOOLEAN?) :: VOID",
        "Change the given user's password.",
        ["admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "dbms.security.clearAuthCache",
        "dbms.security.clearAuthCache() :: VOID",
        "Clears authentication and authorization cache.",
        ["admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "dbms.security.createRole",
        "dbms.security.createRole(roleName :: STRING?) :: VOID",
        "Create a new role.",
        ["admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "dbms.security.createUser",
        "dbms.security.createUser(username :: STRING?, password :: STRING?, requirePasswordChange = true :: BOOLEAN?) :: VOID",
        "Create a new user.",
        ["admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "dbms.security.deleteRole",
        "dbms.security.deleteRole(roleName :: STRING?) :: VOID",
        "Delete the specified role. Any role assignments will be removed.",
        ["admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "dbms.security.deleteUser",
        "dbms.security.deleteUser(username :: STRING?) :: VOID",
        "Delete the specified user.",
        ["admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "dbms.security.listRoles",
        "dbms.security.listRoles() :: (role :: STRING?, users :: LIST? OF STRING?)",
        "List all available roles.",
        ["admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "dbms.security.listRolesForUser",
        "dbms.security.listRolesForUser(username :: STRING?) :: (value :: STRING?)",
        "List all roles assigned to the specified user.",
        ["admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "dbms.security.listUsers",
        "dbms.security.listUsers() :: (username :: STRING?, roles :: LIST? OF STRING?, flags :: LIST? OF STRING?)",
        "List all local users.",
        ["admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "dbms.security.listUsersForRole",
        "dbms.security.listUsersForRole(roleName :: STRING?) :: (value :: STRING?)",
        "List all users currently assigned the specified role.",
        ["admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "dbms.security.removeRoleFromUser",
        "dbms.security.removeRoleFromUser(roleName :: STRING?, username :: STRING?) :: VOID",
        "Unassign a role from the user.",
        ["admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "dbms.security.showCurrentUser",
        "dbms.security.showCurrentUser() :: (username :: STRING?, roles :: LIST? OF STRING?, flags :: LIST? OF STRING?)",
        "Show the current user.",
        ["admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "dbms.security.suspendUser",
        "dbms.security.suspendUser(username :: STRING?) :: VOID",
        "Suspend the specified user.",
        ["admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    },
    {
      "row": [
        "dbms.setTXMetaData",
        "dbms.setTXMetaData(data :: MAP?) :: VOID",
        "Attaches a map of data to the transaction. The data will be printed when listing queries, and inserted into the query log.",
        ["admin"]
      ],
      "meta": [null, null, null, null],
      "graph": { "nodes": [], "relationships": [] }
    }
  ],
  "stats": {
    "nodes_created": 0,
    "nodes_deleted": 0,
    "relationships_created": 0,
    "relationships_deleted": 0,
    "properties_set": 0,
    "labels_added": 0,
    "labels_removed": 0,
    "indexes_added": 0,
    "indexes_removed": 0,
    "constraints_added": 0,
    "constraints_removed": 0,
    "contains_updates": false
  }
}
